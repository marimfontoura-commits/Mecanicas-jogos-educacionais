<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Defesa Cromática</title>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #f6f7f8;
      --line: #d8dbe0;
      --text: #1f2937;
      --muted: #6b7280;
      --ok: #10b981;
      --warn: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", "Segoe UI", sans-serif;
      color: var(--text);
      background: var(--bg);
    }
    .app {
      max-width: 1100px;
      margin: 24px auto;
      padding: 0 16px;
      display: grid;
      grid-template-columns: 1fr 280px;
      gap: 16px;
    }
    .board, .panel {
      border: 1px solid var(--line);
      border-radius: 14px;
      background: #fff;
    }
    .board { padding: 16px; }
    .panel { padding: 16px; background: var(--panel); }
    .hud {
      display: flex;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      font-size: 14px;
    }
    .chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
      background: #fff;
    }
    .path-wrap {
      position: relative;
      height: 260px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      overflow: hidden;
      background: linear-gradient(to bottom, #fff 0, #fff 50%, #fafafa 100%);
    }
    .path {
      position: absolute;
      left: 20px;
      right: 120px;
      top: 115px;
      height: 30px;
      background: #eceef1;
      border: 1px solid #dde1e6;
      border-radius: 20px;
    }
    .paper {
      position: absolute;
      right: 22px;
      top: 92px;
      width: 80px;
      height: 76px;
      border: 2px solid #cfd4dc;
      border-radius: 8px;
      display: grid;
      place-items: center;
      color: #4b5563;
      font-size: 12px;
      background: #fff;
    }
    .slot {
      position: absolute;
      top: 184px;
      width: 42px;
      height: 42px;
      border: 1px solid #cbd2dc;
      border-radius: 10px;
      display: grid;
      place-items: center;
      background: #fff;
      cursor: pointer;
      transition: transform .12s ease, border-color .12s;
      font-weight: 700;
      color: #6b7280;
      user-select: none;
    }
    .slot:hover { transform: translateY(-2px); border-color: #9ca3af; }
    .tower {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display: grid;
      place-items: center;
      border: 1px solid #9ca3af;
      font-size: 12px;
      font-weight: 800;
      background: #f9fafb;
    }
    .range {
      position: absolute;
      top: 90px;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      border: 1px dashed #d1d5db;
      opacity: .5;
      pointer-events: none;
    }
    .ink {
      position: absolute;
      top: 119px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 1px solid #6b7280;
      transition: opacity .2s, transform .2s;
    }
    .ink.dead { opacity: 0; transform: scale(0.5); }
    .flash {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #9ca3af;
      opacity: .6;
      animation: pop .25s forwards;
      pointer-events: none;
    }
    @keyframes pop {
      from { transform: scale(.8); opacity: .5; }
      to { transform: scale(2.1); opacity: 0; }
    }
    .panel h1 { margin: 0 0 8px; font-size: 20px; }
    .small { font-size: 12px; color: var(--muted); line-height: 1.4; }
    .toolbar { margin: 14px 0; display: grid; grid-template-columns: repeat(4,1fr); gap: 8px; }
    .tower-btn, .start {
      border: 1px solid #cfd4dc;
      background: #fff;
      border-radius: 10px;
      padding: 10px;
      font-weight: 700;
      cursor: pointer;
    }
    .tower-btn.active { border-color: #111827; box-shadow: inset 0 0 0 1px #111827; }
    .start {
      width: 100%;
      margin-top: 6px;
      background: #111827;
      color: #fff;
      border-color: #111827;
    }
    .start:disabled { opacity: .4; cursor: not-allowed; }
    .state { margin-top: 10px; font-size: 13px; }
    .next-preview { margin: 10px 0; padding: 10px; border: 1px solid #d9dde3; border-radius: 10px; background: #fff; }
  </style>
</head>
<body>
  <div class="app">
    <section class="board">
      <div class="hud">
        <div class="chip" id="lives">Vidas: 10</div>
        <div class="chip" id="wave">Onda: 1</div>
        <div class="chip" id="kills">Eliminadas: 0</div>
        <div class="chip" id="state">Estado: idle</div>
      </div>
      <div class="path-wrap" id="pathWrap">
        <div class="path"></div>
        <div class="paper">Papel</div>
      </div>
    </section>

    <aside class="panel">
      <h1>Defesa Cromática</h1>
      <p class="small">Posicione torres C, M, Y e K. Uma tinta só é eliminada quando o conjunto de pigmentos atacantes for exatamente igual à decomposição CMYK da cor alvo.</p>
      <div class="next-preview" id="preview">Próxima unidade: -</div>
      <div class="toolbar" id="toolbar"></div>
      <button class="start" id="startBtn">Iniciar Onda</button>
      <div class="state small" id="message">Escolha uma torre e clique nos slots.</div>
    </aside>
  </div>

  <script>
    const COLOR_RULES = {
      Amarelo: ['Y'],
      Magenta: ['M'],
      Ciano: ['C'],
      Vermelho: ['M', 'Y'],
      Verde: ['C', 'Y'],
      Azul: ['C', 'M'],
      Preto: ['K']
    };

    const TOWER_TYPES = ['C', 'M', 'Y', 'K'];
    const INK_COLORS = {
      C: '#d9f0f5', M: '#f7d8e7', Y: '#f8efc8', K: '#d8d8d8',
      Amarelo: '#f8efc8', Magenta: '#f7d8e7', Ciano: '#d9f0f5',
      Vermelho: '#f3d7d7', Verde: '#d9ecd9', Azul: '#dbe4f4', Preto: '#d8d8d8'
    };

    const game = {
      state: 'idle',
      lives: 10,
      wave: 1,
      kills: 0,
      selectedTower: 'C',
      slotCount: 6,
      slots: [],
      towers: [],
      units: [],
      waveQueue: [],
      pathStart: 20,
      pathEnd: 0,
      speed: 68,
      lastTs: 0,
      raf: 0
    };

    const els = {
      pathWrap: document.getElementById('pathWrap'),
      toolbar: document.getElementById('toolbar'),
      preview: document.getElementById('preview'),
      lives: document.getElementById('lives'),
      wave: document.getElementById('wave'),
      kills: document.getElementById('kills'),
      state: document.getElementById('state'),
      message: document.getElementById('message'),
      startBtn: document.getElementById('startBtn')
    };

    function setState(next) {
      game.state = next;
      els.state.textContent = `Estado: ${next}`;
    }

    function asSet(arr) { return new Set(arr); }
    function sameSet(a, b) {
      if (a.size !== b.size) return false;
      for (const item of a) if (!b.has(item)) return false;
      return true;
    }

    function createLayout() {
      const step = (els.pathWrap.clientWidth - 180) / (game.slotCount + 1);
      game.slots = Array.from({ length: game.slotCount }).map((_, i) => {
        const x = Math.round(step * (i + 1));
        const slotEl = document.createElement('button');
        slotEl.className = 'slot';
        slotEl.style.left = `${x}px`;
        slotEl.textContent = '+';
        slotEl.addEventListener('click', () => placeTower(i));
        els.pathWrap.appendChild(slotEl);
        const rangeEl = document.createElement('div');
        rangeEl.className = 'range';
        rangeEl.style.left = `${x - 50}px`;
        rangeEl.style.display = 'none';
        els.pathWrap.appendChild(rangeEl);
        return { x, tower: null, slotEl, rangeEl };
      });
      game.pathEnd = els.pathWrap.clientWidth - 110;
    }

    function renderToolbar() {
      TOWER_TYPES.forEach(type => {
        const b = document.createElement('button');
        b.className = `tower-btn ${game.selectedTower === type ? 'active' : ''}`;
        b.textContent = type;
        b.addEventListener('click', () => {
          game.selectedTower = type;
          [...els.toolbar.children].forEach(el => el.classList.remove('active'));
          b.classList.add('active');
          setState('placing');
          els.message.textContent = `Pigmento ${type} selecionado.`;
        });
        els.toolbar.appendChild(b);
      });
    }

    function placeTower(slotIndex) {
      if (!['idle', 'placing', 'wavePreview'].includes(game.state)) return;
      const slot = game.slots[slotIndex];
      slot.tower = game.selectedTower;
      slot.slotEl.innerHTML = `<div class="tower">${game.selectedTower}</div>`;
      slot.rangeEl.style.display = 'block';
      upsertTower(slotIndex, slot.x, game.selectedTower);
      setState('placing');
      els.message.textContent = `Torre ${game.selectedTower} posicionada no slot ${slotIndex + 1}.`;
      updatePreview();
    }

    function upsertTower(slotIndex, x, pigment) {
      const found = game.towers.find(t => t.slotIndex === slotIndex);
      if (found) found.pigment = pigment;
      else game.towers.push({ id: `t-${slotIndex}`, slotIndex, x, pigment, range: 70 });
    }

    function generateWave(waveNum) {
      const total = Math.min(4 + waveNum, 10);
      const placedPigments = new Set(game.towers.map(t => t.pigment));
      const allEntries = Object.entries(COLOR_RULES);
      const solvable = allEntries.filter(([, req]) => req.every(p => placedPigments.has(p)));
      const pool = solvable.length ? solvable : allEntries;
      return Array.from({ length: total }).map((_, i) => {
        const [name, req] = pool[(i + waveNum) % pool.length];
        return { name, required: req };
      });
    }

    function updatePreview() {
      game.waveQueue = generateWave(game.wave);
      const next = game.waveQueue[0];
      els.preview.textContent = `Próxima unidade: ${next.name} [${next.required.join('+')}]`;
      setState('wavePreview');
    }

    function spawnUnits() {
      game.units = game.waveQueue.map((u, i) => {
        const el = document.createElement('div');
        el.className = 'ink';
        el.style.background = INK_COLORS[u.name];
        el.style.left = `${game.pathStart - i * 40}px`;
        els.pathWrap.appendChild(el);
        return {
          ...u,
          x: game.pathStart - i * 40,
          entered: false,
          evaluated: false,
          accumulated: new Set(),
          currentlyInRange: new Set(),
          el
        };
      });
    }

    function showFlash(x, y) {
      const f = document.createElement('div');
      f.className = 'flash';
      f.style.left = `${x}px`;
      f.style.top = `${y}px`;
      els.pathWrap.appendChild(f);
      setTimeout(() => f.remove(), 250);
    }

    function evaluateUnit(unit) {
      if (unit.evaluated) return;
      unit.evaluated = true;
      const ok = sameSet(unit.accumulated, asSet(unit.required));
      if (ok) {
        unit.el.classList.add('dead');
        setTimeout(() => unit.el.remove(), 180);
        game.kills += 1;
      }
    }

    function updateUnits(dt) {
      const placedSet = new Set(game.towers.map(t => t.pigment));
      for (const unit of game.units) {
        if (unit.evaluated) continue;
        unit.x += game.speed * dt;
        unit.el.style.left = `${unit.x}px`;

        const inRangeNow = game.towers.filter(t => Math.abs(unit.x - t.x) <= t.range);
        unit.currentlyInRange = new Set(inRangeNow.map(t => t.id));

        if (inRangeNow.length) {
          unit.entered = true;
          inRangeNow.forEach(t => unit.accumulated.add(t.pigment));
          showFlash(unit.x + 8, 124);
        }

        const hitAllPlacedPigments = sameSet(unit.accumulated, placedSet);
        if ((unit.entered && inRangeNow.length === 0) || hitAllPlacedPigments) {
          evaluateUnit(unit);
          continue;
        }

        if (unit.x >= game.pathEnd) {
          evaluateUnit(unit);
          if (!unit.el.classList.contains('dead')) {
            game.lives -= 1;
            unit.el.remove();
            unit.evaluated = true;
          }
        }
      }

      game.units = game.units.filter(u => !u.evaluated || !u.el.isConnected || !u.el.classList.contains('dead'));
    }

    function updateHud() {
      els.lives.textContent = `Vidas: ${game.lives}`;
      els.wave.textContent = `Onda: ${game.wave}`;
      els.kills.textContent = `Eliminadas: ${game.kills}`;
    }

    function finishWaveIfNeeded() {
      const alive = [...els.pathWrap.querySelectorAll('.ink')].length;
      if (alive === 0) {
        if (game.lives <= 0) {
          setState('gameOver');
          els.message.textContent = 'Game Over: o papel foi saturado.';
          els.startBtn.disabled = true;
          cancelAnimationFrame(game.raf);
          return;
        }
        setState('waveEnd');
        els.message.textContent = 'Fim da onda. Ajuste torres e inicie a próxima.';
        game.wave += 1;
        updatePreview();
      }
    }

    function loop(ts) {
      if (!game.lastTs) game.lastTs = ts;
      const dt = (ts - game.lastTs) / 1000;
      game.lastTs = ts;
      if (game.state === 'waveRunning') {
        updateUnits(dt);
        updateHud();
        finishWaveIfNeeded();
      }
      game.raf = requestAnimationFrame(loop);
    }

    function startWave() {
      if (!game.towers.length || game.state === 'waveRunning' || game.state === 'gameOver') return;
      [...els.pathWrap.querySelectorAll('.ink,.flash')].forEach(n => n.remove());
      spawnUnits();
      setState('waveRunning');
      els.message.textContent = 'Onda em andamento...';
    }

    function init() {
      createLayout();
      renderToolbar();
      updatePreview();
      updateHud();
      els.startBtn.addEventListener('click', startWave);
      game.raf = requestAnimationFrame(loop);
      window.addEventListener('beforeunload', () => cancelAnimationFrame(game.raf));
    }

    init();
  </script>
</body>
</html>
